<!--
@license
Copyright (c) 2015 The Polymer Project Authors. All rights reserved.
This code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt
The complete set of authors may be found at http://polymer.github.io/AUTHORS.txt
The complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt
Code distributed by Google as part of the polymer project is also
subject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt
-->

<link rel="import" href="../polymer/polymer.html">
<link rel="import" href="firebase.html">

<!--
Element wrapper for the Firebase Web API (http://firebase.com).

`firebase-element` maps a firebase location to a `data` property.

    <firebase-element id="base" location="https://YOUR.firebaseio.com/" data="{{data}}" keys="{{keys}}"></firebase-element>

    <h3>My Firebase Data</h3>

    <template repeat="[[keys]]" as="key">
      <p>{{printValue(data, key)}}</p>
    </template>

  - changes that occur on the remote data are automatically reflected back into
    the client-side data.
  - assignments to the `data` property, or modifications to `data`'s
    **observed** subtree properties, are automatically persisted back to the
    Firebase store.
-->

<script>
  Polymer({
    is: 'firebase-element',

    properties: {

      /**
       * Firebase Query object corresponding to `location`.
       */
      ref: {
        type: Object,
        readOnly: true,
        notify: true,
        observer: '_onRefChanged',
        reflectToAttribute: true
      },

      /**
       * The `data` object mapped to `location`.
       */
      data: {
        type: Object,
        notify: true
      },

      /**
       * All keys in data (array of names, if you think of data as a set of
       * name/value pairs).
       */
      keys: {
        type: Array,
        readOnly: true,
        notify: true
      },

      /**
       * Firebase location mapped to `data`.
       */
      location: {
        type: String,
        observer: '_updateRef',
        reflectToAttribute: true
      },

      /**
       * Specify a child key to order the set of records reflected on the
       * client.
       */
      orderByChild: {
        type: String,
        value: '',
        observer: '_updateRef',
        reflectToAttribute: true
      },

      /**
       * Specify to order by key the set of records reflected on the client.
       */
      orderByKey: {
        type: Boolean,
        value: false,
        observer: '_updateRef',
        reflectToAttribute: true
      },

      /**
       * Specify to order by value the set of records reflected on the client.
       */
      orderByValue: {
        type: Boolean,
        value: false,
        observer: '_updateRef',
        reflectToAttribute: true
      },

      /**
       * Specify to order by priority the set of records reflected on the
       * client.
       */
      orderByPriority: {
        type: Boolean,
        value: false,
        observer: '_updateRef',
        reflectToAttribute: true
      },

      /**
       * Specify a maximum number of records reflected on the client limited to
       * the first certain number of children.
       */
      limitToFirst: {
        type: Number,
        observer: '_updateRef',
        reflectToAttribute: true
      },

      /**
       * Specify a maximum number of records reflected on the client limited to
       * the last certain number of children.
       */
      limitToLast: {
        type: Number,
        observer: '_updateRef',
        reflectToAttribute: true
      },

      /**
       * Specify an start record for the set of records reflected on the client.
       */
      startAt: {
        type: String,
        observer: '_updateRef',
        reflectToAttribute: true
      },

      /**
       * Specify to create a query which includes children which match the
       * specified value. The argument type depends on which orderBy*() function
       * was used in this query. Specify a value that matches the orderBy*()
       * type.
       */
      equalTo: {
        type: String,
        observer: '_updateRef',
        reflectToAttribute: true
      },

      /**
       * When set, data will be stored with the given Firebase priority level.
       */
      priority: {
        type: Number
      },

      /**
       * If true, will log various occurances to the console api.
       */
      log: {
        type: Boolean,
        value: false
      },

      _orderByMethodName: {
        computed: '_computeOrderByMethodName(orderByChild, orderByKey, orderByValue, orderByPriority)'
      },

      _orderByTypeCast: {
        computed: '_computeOrderByTypeCast(orderByChild, orderByKey, orderByValue, orderByPriority)'
      },

      _startAt: {
        computed: '_computeStartAt(startAt, _orderByTypeCast)'
      },

      _equalTo: {
        computed: '_computeEqualTo(equalTo, _orderByTypeCast)'
      }
    },

    observers: [
      '_updateData(data.*)'
    ],

    reset: function() {
      this._updateRef();
    },

    _updateRef: function() {
      var ref;

      if (!this.location) {
        return;
      }

      ref = new Firebase(this.location);

      if (this.orderByMethodName) {
        if (this.orderByMethodName === 'orderByChild') {
          ref = ref[this.orderByMethodName](this.orderByChild);
        } else {
          ref = ref[this.orderByMethodName]();
        }
      }

      if (this.startAt !== undefined) {
        ref = ref.startAt(this.startAt);
      }

      if (this.equalTo !== undefined) {
        ref = ref.equalTo(this.equalTo);
      }

      if (this.limitToLast !== undefined) {
        ref = ref.limitToLast(this.limitToLast);
      }

      if (this.limitToFirst !== undefined) {
        ref = ref.limitToFirst(this.limitToFirst);
      }

      this._setRef(ref);
    },

    _onRefChanged: function(ref, oldRef) {
      if (oldRef) {
        this._stopListeningTo(oldRef);
      }

      this._listenTo(ref);
    },

    _listenTo: function(ref) {
      ref.on('value', this._onRefValue, this._onRefCancel, this);
      ref.on('child_added', this._onRefChildAdded, this._onRefCancel, this);
      ref.on('child_removed', this._onRefChildRemoved, this._onRefCancel, this);
      ref.on('child_changed', this._onRefChildChanged, this._onRefCancel, this);
    },

    _stopListening: function(ref) {
      ref.off('value', this._onRefValue, this._onRefCancel, this);
      ref.off('child_added', this._onRefChildAdded, this._onRefCancel, this);
      ref.off('child_removed', this._onRefChildRemoved, this._onRefCancel, this);
      ref.off('child_changed', this._onRefChildChanged, this._onRefCancel, this);
    },

    _onRefValue: function(snapshot) {
      this._log('Firebase Event: "value"', snapshot.val());
      this.set('data', snapshot.val());
      this.fire('value', snapshot, { bubbles: false });
    },

    _onRefChildAdded: function(childSnapshot) {
      this._log('Firebase Event: "child_added"', childSnapshot.val());
      this.fire('child-added', childSnapshot, { bubbles: false });
    },

    _onRefChildRemoved: function(oldChildSnapshot) {
      this._log('Firebase Event: "child_removed"', oldChildSnapshot.val());
      this.fire('child-removed', oldChildSnapshot, { bubbles: false });
    },

    _onRefChildChanged: function(childSnapshot) {
      this._log('Firebase Event: "child_changed"', childSnapshot.val());
      this.fire('child-changed', childSnapshot, { bubbles: false });
    },

    _onRefCancel: function(error) {
      this._error('Firebase Error', error);
      this._log('Firebase subscription cancelled; disposing of query.');

      if (this.ref) {
        this._stopListeningTo(this.ref);
        this._setRef(undefined);
      }
    },

    _updateData: function(change) {
      this.debounce('update-data', function() {
        this._log('Updating remote data with local changes.');

        if (this.priority != null) {
          this.ref.setWithPriority(this.data, this.priority);
        } else {
          this.ref.set(this.data);
        }

        this._setKeys(this.data ? Object.keys(this.data) : []);
      });
    },

    _computeOrderByMethodName: function(orderByChild, orderByKey, orderByValue, orderByPriority) {
      if (orderByChild) {
        return 'orderByChild';
      }

      if (orderByKey) {
        return 'orderByKey';
      }

      if (orderByValue) {
        return 'orderByValue';
      }

      if (orderByPriority) {
        return 'orderByPriority';
      }

      return null;
    },

    _computeOrderByTypeCast: function(orderByChild, orderByKey, orderByValue, orderByPriority) {
      if (orderByKey) {
        return String;
      }

      return function(value) {
        return value;
      }
    },

    _computeStartAt: function(startAt, _orderByTypeCast) {
      return _orderByTypeCast(startAt);
    },

    _computeEqualTo: function(equalTo, _orderByTypeCast) {
      return _orderByTypeCast(equalTo);
    },

    _log: function() {
      if (this.log) {
        console.log.apply(console, arguments);
      }
    },

    _error: function() {
      if (this.log) {
        console.error.apply(console, arguments);
      }
    }
  })
</script>
